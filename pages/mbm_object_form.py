# pages/mbm_object_form.py
import json, uuid, time, datetime
import requests
import streamlit as st

# =============== ÌéòÏù¥ÏßÄ Ìó§Îçî ===============
st.set_page_config(page_title="üßöüèª‚Äç‚ôÇÔ∏è MBM Magic Wizard", page_icon="üìÑ", layout="centered")
st.title("üßöüèª‚Äç‚ôÇÔ∏è MBM Magic Wizard")
st.caption("MBM Ïò§Î∏åÏ†ùÌä∏ ÌòïÏÑ±Î∂ÄÌÑ∞ ÎßàÏºÄÌåÖ ÏóêÏÖãÍπåÏßÄ ÌïúÎ≤àÏóê ÎßåÎì§Ïñ¥Ï§ÑÍ≤åÏöî.")

# =============== ÏÑ§Ï†ïÍ∞í & ÏÉÅÏàò ===============
TOKEN = st.secrets.get("HUBSPOT_PRIVATE_APP_TOKEN", "")
if not TOKEN:
    st.error("Streamlit SecretsÏóê HUBSPOT_PRIVATE_APP_TOKENÏù¥ ÏóÜÏäµÎãàÎã§.")
    st.stop()

PORTAL_ID = st.secrets.get("PORTAL_ID", "2495902")
HUBSPOT_REGION = "na1"

# Website Page ÌÖúÌîåÎ¶ø (Website Ï†ÑÏö©) ‚Äî Í∏∞Î≥∏Í∞íÏùÄ Ï£ºÏã† ÌÖúÌîåÎ¶øÏùò ÌéòÏù¥ÏßÄ ID
LANDING_PAGE_TEMPLATE_ID = st.secrets.get("LANDING_PAGE_TEMPLATE_ID", "194363146790")
WEBSITE_PAGE_TEMPLATE_TITLE = st.secrets.get("WEBSITE_PAGE_TEMPLATE_TITLE", "[Template] Event Landing Page_GOM")

# Email ÌÖúÌîåÎ¶ø
EMAIL_TEMPLATE_ID = st.secrets.get("EMAIL_TEMPLATE_ID", "162882078001")

# Register Form ÌÖúÌîåÎ¶ø(guid)
REGISTER_FORM_TEMPLATE_GUID = "83e40756-9929-401f-901b-8e77830d38cf"

# MBM Ïò§Î∏åÏ†ùÌä∏ Í∏∞Î≥∏ ÏÑ§Ï†ï
MBM_HIDDEN_FIELD_NAME = "title"        # Register Form Ïà®ÍπÄ ÌïÑÎìú Ïù¥Î¶Ñ
ACCESS_PASSWORD = "mid@sit0901"        # Î≥∏Î¨∏ Ï†ëÍ∑º Î≥¥Ìò∏ ÎπÑÎ∞ÄÎ≤àÌò∏

HS_BASE = "https://api.hubapi.com"
HEADERS_JSON = {
    "Authorization": f"Bearer {TOKEN}",
    "Content-Type": "application/json",
    "Accept": "application/json",
}

# Ïä§ÌÇ§ÎßàÏóêÏÑú Î≥¥Ïó¨Ï§Ñ ÌïÑÎìú(ÏöîÏ≤≠ÌïòÏã† ÎÇ¥Î∂ÄÎ™Ö ÏàúÏÑú)
MBM_FIELDS = [
    "title",
    "country",
    "mbm_type",
    "city",
    "location",
    "mbm_start_date",
    "mbm_finish_date",
    "target_audience",
    "description_of_detailed_targets___________",
    "purpose_of_mbm",
    "expected_earnings",
    "product__midas_",
    "campaign_key_item",
    "market_conditions",
    "pain_point_of_target",
    "benefits",
]
# Ìï≠ÏÉÅ Ïà®ÍπÄ + TrueÎ°ú Ï†ÑÏÜ°
MBM_HIDDEN_TRUE = "auto_generate_campaign"

# Í∏¥ ÌÖçÏä§Ìä∏Î°ú ÌëúÏãúÌï† ÌõÑÎ≥¥
LONG_TEXT_FIELDS = {
    "description_of_detailed_targets___________",
    "purpose_of_mbm",
    "market_conditions",
    "pain_point_of_target",
    "benefits",
}

# =============== ÏÑ∏ÏÖò ÏÉÅÌÉú ===============
ss = st.session_state
ss.setdefault("auth_ok", False)         # Ï†ëÍ∑º ÌóàÏö© Ïó¨Î∂Ä
ss.setdefault("active_stage", 1)        # 1=Ï†úÏ∂ú, 2=ÏÑ†ÌÉù, 3=Í≥µÏú†
ss.setdefault("mbm_submitted", False)   # ‚ë† ÏôÑÎ£å Ïó¨Î∂Ä (MBM ÏÉùÏÑ± ÏôÑÎ£å or Ïä§ÌÇµ)
ss.setdefault("mbm_title", "")
ss.setdefault("show_prop_form", False)  # ‚ë† ÌÉÄÏù¥ÌãÄ Îã§Ïùå ‚Üí ÏÉÅÏÑ∏ Ìèº ÌéºÏπ®
ss.setdefault("results", None)          # {"title": str, "links": dict}
ss.setdefault("mbm_object", None)       # {"id": "...", "typeId": "...", "url": "record url"}

# =============== Î≥∏Î¨∏ Ï†ëÍ∑º ÏïîÌò∏ (ÏÇ¨Ïù¥ÎìúÎ∞î X, Î≥∏Î¨∏Ïóê ÌëúÏãú) ===============
if not ss.auth_ok:
    box = st.container(border=True)
    with box:
        st.subheader("üîí Access")
        st.caption("Ìï¥Îãπ Í∏∞Îä•ÏùÄ ÎßàÏù¥Îã§Ïä§ÏïÑÏù¥Ìã∞ Íµ¨ÏÑ±ÏõêÎßå ÏûÖÎ†•Ïù¥ Í∞ÄÎä•Ìï©ÎãàÎã§. MBM ÏóêÏÖã ÏÉùÏÑ±ÏùÑ ÏúÑÌï¥ ÎπÑÎ∞ÄÎ≤àÌò∏Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.")
        colp1, colp2 = st.columns([5, 1])
        with colp1:
            pwd = st.text_input("ÎπÑÎ∞ÄÎ≤àÌò∏", type="password", label_visibility="collapsed", placeholder="ÎπÑÎ∞ÄÎ≤àÌò∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî")
        with colp2:
            if st.button("Ï†ëÏÜç", use_container_width=True):
                if pwd == ACCESS_PASSWORD:
                    ss.auth_ok = True
                    st.rerun()
                else:
                    st.error("ÏïîÌò∏Í∞Ä ÏùºÏπòÌïòÏßÄ ÏïäÏäµÎãàÎã§.")
                    st.info("ÎèÑÏõÄÎßê: ÏÇ¨ÎÇ¥ Í≥µÏßÄ Î©îÏùº ÎòêÎäî Í¥ÄÎ¶¨ÏûêÏóêÍ≤å Î¨∏ÏùòÌï¥Ï£ºÏÑ∏Ïöî.")
    st.stop()

# =============== Ïú†Ìã∏ ===============
def ordinal(n: int) -> str:
    n = int(n)
    if 10 <= (n % 100) <= 20: suf = "th"
    else: suf = {1:"st", 2:"nd", 3:"rd"}.get(n % 10, "th")
    return f"{n}{suf}"

def copy_button(text: str, key: str):
    safe = json.dumps(text)
    st.components.v1.html(
        f"""
        <button id="copybtn_{key}" title="Î≥µÏÇ¨"
          style="padding:8px 10px;border:1px solid #e5e7eb;border-radius:10px;background:#fff;cursor:pointer;">üìã</button>
        <span id="copied_{key}" style="display:none;margin-left:6px;color:#16a34a;font-size:12px;">Î≥µÏÇ¨Îê®</span>
        <script>
        document.getElementById('copybtn_{key}').onclick=()=>{{
          navigator.clipboard.writeText({safe}).then(() => {{
            const m=document.getElementById('copied_{key}');
            m.style.display='inline'; setTimeout(()=>{{m.style.display='none'}}, 1500);
          }});
        }};
        </script>
        """,
        height=40, width=120
    )

def to_epoch_ms(d: datetime.date | None) -> str | None:
    if not d: return None
    dt = datetime.datetime(d.year, d.month, d.day, 0, 0, 0)
    return str(int(time.mktime(dt.timetuple()) * 1000))

def human_label(internal: str) -> str:
    mapping = {
        "auto_generate_campaign": "ÏûêÎèô Ï∫†ÌéòÏù∏ ÏÉùÏÑ± (Ïà®ÍπÄ)",
        "title": "MBM Ïò§Î∏åÏ†ùÌä∏ ÌÉÄÏù¥ÌãÄ",
        "country": "Íµ≠Í∞Ä",
        "mbm_type": "MBM ÌÉÄÏûÖ",
        "city": "ÎèÑÏãú",
        "location": "Ïû•ÏÜå",
        "mbm_start_date": "ÏãúÏûëÏùº",
        "mbm_finish_date": "Ï¢ÖÎ£åÏùº",
        "target_audience": "ÌÉÄÍ≤ü",
        "description_of_detailed_targets___________": "ÌÉÄÍ≤ü ÏÉÅÏÑ∏ ÏÑ§Î™Ö",
        "purpose_of_mbm": "Î™©Ï†Å",
        "expected_earnings": "ÏòàÏÉÅ ÏàòÏùµ",
        "product__midas_": "Ï†úÌíà(MIDAS)",
        "campaign_key_item": "Ï∫†ÌéòÏù∏ ÌïµÏã¨ Ìï≠Î™©",
        "market_conditions": "ÏãúÏû• ÏÉÅÌô©",
        "pain_point_of_target": "ÌÉÄÍ≤ü Pain Point",
        "benefits": "ÌïµÏã¨ Î≤†ÎÑ§Ìïè",
    }
    return mapping.get(internal, internal)

# =============== HubSpot API ===============
# --- Website Page Ï†ÑÏö© ---
def hs_clone_site_page(template_id: str, clone_name: str) -> dict:
    url = f"{HS_BASE}/cms/v3/pages/site-pages/clone"
    last = None
    for key in ("name", "cloneName"):
        r = requests.post(url, headers=HEADERS_JSON, json={"id": str(template_id), key: clone_name}, timeout=45)
        if r.status_code < 400:
            return r.json()
        last = r
    last.raise_for_status()

def hs_update_site_page_name(page_id: str, new_name: str) -> None:
    url = f"{HS_BASE}/cms/v3/pages/site-pages/{page_id}"
    r = requests.patch(url, headers=HEADERS_JSON, json={"name": new_name}, timeout=30)
    if r.status_code >= 400:
        st.warning(f"ÌéòÏù¥ÏßÄ ÎÇ¥Î∂Ä Ïù¥Î¶Ñ Î≥ÄÍ≤Ω Ïã§Ìå®: {r.status_code}")

def hs_push_live_site(page_id: str) -> None:
    url = f"{HS_BASE}/cms/v3/pages/site-pages/{page_id}/draft/push-live"
    r = requests.post(url, headers={"Authorization": f"Bearer {TOKEN}", "Accept": "*/*"}, timeout=30)
    r.raise_for_status()

def hs_get_site_page(page_id: str) -> dict:
    url = f"{HS_BASE}/cms/v3/pages/site-pages/{page_id}"
    r = requests.get(url, headers=HEADERS_JSON, timeout=30)
    r.raise_for_status()
    return r.json()

def extract_best_live_url(page_json: dict) -> str | None:
    for k in ("publicUrl", "url", "absoluteUrl", "absolute_url", "publishedUrl"):
        val = page_json.get(k)
        if isinstance(val, str) and val.strip():
            return val.strip()
    return None

# ---- Website pages Î™©Î°ù Í≤ÄÏÉâ (Ï†úÎ™©/ÌÇ§ÏõåÎìúÎ°ú ÏûêÎèô Ìï¥Í≤∞) ----
def list_site_pages(limit_per_page: int = 100):
    after = None
    while True:
        params = {"limit": limit_per_page}
        if after:
            params["after"] = after
        r = requests.get(f"{HS_BASE}/cms/v3/pages/site-pages", headers=HEADERS_JSON, params=params, timeout=30)
        r.raise_for_status()
        data = r.json()
        items = data.get("results") or data.get("items") or []
        for it in items:
            yield it
        after = (data.get("paging") or {}).get("next", {}).get("after")
        if not after:
            break

def find_site_page_id_smart(title_hint: str | None) -> str | None:
    title_hint = (title_hint or "").strip()
    if title_hint:
        for it in list_site_pages():
            name = (it.get("name") or "").strip()
            page_title = (it.get("pageTitle") or it.get("htmlTitle") or "").strip()
            if name == title_hint or page_title == title_hint:
                return str(it.get("id") or it.get("objectId") or "")
    best = None; best_score = -1
    for it in list_site_pages():
        text = " ".join([
            (it.get("name") or ""),
            (it.get("pageTitle") or ""),
            (it.get("htmlTitle") or "")
        ]).lower()
        score = 0
        if "template" in text: score += 2
        if "mbm" in text: score += 2
        if "landing" in text: score += 1
        if "webinar" in text: score += 1
        if score > best_score:
            best_score = score; best = it
    if best and best_score > 0:
        return str(best.get("id") or best.get("objectId") or "")
    return None

def clone_site_page_with_fallback(primary_id: str, clone_name: str, title_hint: str | None) -> dict:
    try:
        return hs_clone_site_page(primary_id, clone_name)
    except requests.HTTPError as e:
        if e.response is not None and e.response.status_code == 404:
            resolved = find_site_page_id_smart(title_hint)
            if resolved:
                return hs_clone_site_page(resolved, clone_name)
        raise

# ---- Emails ----
def hs_clone_marketing_email(template_email_id: str, clone_name: str) -> dict:
    url = f"{HS_BASE}/marketing/v3/emails/clone"
    last_err = None
    for key in ("emailName", "name", "cloneName"):
        try:
            r = requests.post(url, headers=HEADERS_JSON,
                              json={"id": str(template_email_id), key: clone_name},
                              timeout=45)
            r.raise_for_status()
            return r.json()
        except requests.HTTPError as e:
            last_err = e
    raise last_err

def hs_update_email_name(email_id: str, new_name: str):
    url = f"{HS_BASE}/marketing/v3/emails/{email_id}"
    r = requests.patch(url, headers=HEADERS_JSON, json={"name": new_name}, timeout=30)
    if r.status_code >= 400:
        st.warning(f"Ïù¥Î©îÏùº ÎÇ¥Î∂Ä Ïù¥Î¶Ñ Î≥ÄÍ≤Ω Ïã§Ìå®: {r.status_code}")

# ---- Forms v2: Register Form Î≥µÏ†ú + Ïà®ÍπÄÍ∞í Ï£ºÏûÖ ----
FORMS_V2 = "https://api.hubapi.com/forms/v2"

def hs_get_form_v2(form_guid: str) -> dict:
    url = f"{FORMS_V2}/forms/{form_guid}"
    r = requests.get(url, headers={"Authorization": f"Bearer {TOKEN}", "Accept": "application/json"}, timeout=30)
    r.raise_for_status()
    return r.json()

def _strip_field_for_create(field: dict) -> dict:
    allow = {"name","label","type","fieldType","required","hidden","defaultValue",
             "placeholder","validation","displayAsCheckbox","options","description","inlineHelpText"}
    return {k: v for k, v in field.items() if k in allow}

def _normalize_groups(form_json: dict) -> list[dict]:
    groups = []
    for g in form_json.get("formFieldGroups", []):
        fields = [_strip_field_for_create(f) for f in g.get("fields", [])]
        groups.append({"fields": fields})
    return groups

def hs_create_form_v2(payload: dict) -> dict:
    url = f"{FORMS_V2}/forms"
    r = requests.post(url, headers={"Authorization": f"Bearer {TOKEN}", "Content-Type": "application/json"},
                      json=payload, timeout=45)
    r.raise_for_status()
    return r.json()

def clone_form_with_hidden_value(template_guid: str, new_name: str, hidden_value: str, hidden_field_name: str) -> dict:
    tpl = hs_get_form_v2(template_guid)
    groups = _normalize_groups(tpl)
    found = False
    for g in groups:
        for f in g["fields"]:
            if f.get("name") == hidden_field_name:
                f["hidden"] = True
                f["defaultValue"] = hidden_value
                found = True
    if not found:
        if not groups:
            groups = [{"fields": []}]
        groups[-1]["fields"].append({
            "name": hidden_field_name,
            "label": "MBM Title (auto)",
            "type": "string",
            "fieldType": "text",
            "hidden": True,
            "defaultValue": hidden_value,
        })
    payload = {
        "name": new_name,
        "method": tpl.get("method", "POST"),
        "redirect": tpl.get("redirect", ""),
        "submitText": tpl.get("submitText", "Submit"),
        "formFieldGroups": groups,
    }
    return hs_create_form_v2(payload)

# ---- MBM Custom Object Ïä§ÌÇ§Îßà/ÏÉùÏÑ± ----
def get_custom_object_schemas() -> dict:
    url = f"{HS_BASE}/crm/v3/schemas"
    r = requests.get(url, headers=HEADERS_JSON, timeout=30)
    r.raise_for_status()
    return r.json()

def resolve_mbm_schema() -> dict | None:
    data = get_custom_object_schemas()
    for s in data.get("results", []):
        name = (s.get("name") or "").lower()
        label = (s.get("labels", {}).get("singular") or "").lower()
        if "mbm" in name or "mbm" in label:
            return s
    for s in data.get("results", []):
        if any(p.get("name") == "title" for p in s.get("properties", [])):
            return s
    return None

def get_mbm_properties_map() -> dict[str, dict]:
    sch = resolve_mbm_schema()
    if not sch:
        raise RuntimeError("MBM Ïò§Î∏åÏ†ùÌä∏ Ïä§ÌÇ§ÎßàÎ•º Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§.")
    return {p.get("name"): p for p in sch.get("properties", [])}

def hs_create_mbm_object(properties: dict) -> dict:
    schema = resolve_mbm_schema()
    if not schema:
        raise RuntimeError("MBM Ïò§Î∏åÏ†ùÌä∏ Ïä§ÌÇ§ÎßàÎ•º Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§. (Ìè¨ÌÑ∏ÏóêÏÑú Ïª§Ïä§ÌÖÄ Ïò§Î∏åÏ†ùÌä∏ Ï†ïÏùòÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî)")
    fqn = schema.get("fullyQualifiedName") or schema.get("name")
    url = f"{HS_BASE}/crm/v3/objects/{fqn}"
    r = requests.post(url, headers=HEADERS_JSON, json={"properties": properties}, timeout=45)
    r.raise_for_status()
    obj = r.json()
    obj_id = str(obj.get("id") or obj.get("objectId") or "")
    type_id = schema.get("objectTypeId") or ""
    record_url = f"https://app.hubspot.com/contacts/{PORTAL_ID}/record/{type_id}/{obj_id}"
    return {"id": obj_id, "typeId": type_id, "url": record_url, "raw": obj}

# =============== ÌÉ≠ Íµ¨ÏÑ± ===============
TAB1 = "MBM Ïò§Î∏åÏ†ùÌä∏ Ï†úÏ∂ú"
TAB2 = "ÌõÑÏÜç ÏûëÏóÖ ÏÑ†ÌÉù"
TAB3 = "ÏµúÏ¢Ö ÎßÅÌÅ¨ Í≥µÏú†"

def _focus_tab(label: str):
    import json as _json
    safe_label = _json.dumps(label)
    st.components.v1.html(
        f"""
        <script>
        (function(){{
          const targetText = {safe_label};
          function clickTarget(root) {{
            const tabs = root.querySelectorAll('[role="tab"]');
            for (const t of tabs) {{
              const txt = (t.innerText || t.textContent || "").trim();
              if (txt === targetText || txt.indexOf(targetText) !== -1) {{ t.click(); return true; }}
            }}
            return false;
          }}
          function tryClick() {{
            const doc = window.parent?.document || document;
            if (clickTarget(doc)) return true;
            const frames = doc.querySelectorAll('iframe');
            for (const f of frames) {{
              try {{ if (f.contentDocument && clickTarget(f.contentDocument)) return true; }} catch (e) {{}}
            }}
            return false;
          }}
          let attempts = 0;
          const id = setInterval(() => {{
            attempts++;
            if (tryClick() || attempts >= 20) clearInterval(id);
          }}, 200);
          const targetDoc = window.parent?.document || document;
          const obs = new MutationObserver(() => tryClick());
          obs.observe(targetDoc, {{subtree:true, childList:true}});
          setTimeout(()=>obs.disconnect(), 5000);
        }})();
        </script>
        """,
        height=0, width=0
    )

def make_tabs():
    labels = [TAB1]
    if ss.mbm_submitted:
        labels.append(TAB2)
    if ss.results:
        labels.append(TAB3)
    try:
        t = st.tabs(labels, key="mbm_tabs")
    except TypeError:
        t = st.tabs(labels)
    idx = {label: i for i, label in enumerate(labels)}
    if ss.active_stage == 2 and TAB2 in idx:
        _focus_tab(TAB2)
    elif ss.active_stage == 3 and TAB3 in idx:
        _focus_tab(TAB3)
    return t, idx

# === ÌÉ≠Î∞îÎäî Îã® Ìïú Î≤àÎßå ÏÉùÏÑ± (Ï§ëÎ≥µ Î†åÎçî Î∞©ÏßÄ) ===
tabs, idx = make_tabs()

# =============== ÌÉ≠‚ë†: MBM Ïò§Î∏åÏ†ùÌä∏ Ï†úÏ∂ú (Ïä§ÌÇ§Îßà Í∏∞Î∞ò ÏúÑÏ†Ø) ===============
with tabs[idx[TAB1]]:
    st.markdown("### ‚ë† MBM Ïò§Î∏åÏ†ùÌä∏ Ï†úÏ∂ú")

    # 1-1) ÌÉÄÏù¥ÌãÄ Î®ºÏ†Ä ÏûÖÎ†• ‚Üí [Îã§Ïùå] ÎàÑÎ•¥Î©¥ ÏÉÅÏÑ∏ ÌèºÏù¥ ÌéºÏ≥êÏßê
    st.markdown("**MBM Ïò§Î∏åÏ†ùÌä∏ ÌÉÄÏù¥ÌãÄ ÏÑ§Ï†ï**")
    st.markdown("ÎÑ§Ïù¥Î∞ç Í∑úÏπô: `[Íµ≠Í∞ÄÏΩîÎìú] YYYYMMDD Ïõ®ÎπÑÎÇòÎ™Ö` ÌòïÏãùÏúºÎ°ú ÏûÖÎ†•ÌïòÏÑ∏Ïöî.")
    c1, c2 = st.columns([6, 1])
    with c1:
        ss.mbm_title = st.text_input(
            "ÌèºÏùò 'Title'Í≥º ÎèôÏùºÌïòÍ≤å ÏûÖÎ†•",
            key="mbm_title_input",
            value=ss.mbm_title,
            placeholder="[EU] 20250803 GTS NX Webinar",
            label_visibility="collapsed",
        )
    with c2:
        copy_button(ss.mbm_title, key=f"title_{uuid.uuid4()}")

    ca, cb, cc = st.columns([2,2,1])
    with ca:
        if st.button("Îã§Ïùå ‚ñ∂ ÌïÑÎìú ÏûÖÎ†• Ïó¥Í∏∞", use_container_width=True, type="primary", disabled=not ss.mbm_title):
            if not ss.mbm_title:
                st.error("MBM Ïò§Î∏åÏ†ùÌä∏ ÌÉÄÏù¥ÌãÄÏùÑ Î®ºÏ†Ä ÏûÖÎ†•ÌïòÏÑ∏Ïöî.")
            else:
                ss.show_prop_form = True
                ss.mbm_submitted = False  # Skip ÌõÑ Îã§Ïãú Ìèº Ïó¥Î¶¥ Ïàò ÏûàÎèÑÎ°ù Î¶¨ÏÖã
                st.rerun()
    with cb:
        # Ïù¥ÎØ∏ ÏÉùÏÑ±Ìïú Í≤ΩÏö∞ Ïä§ÌÇµ
        if st.button("Ïù¥ÎØ∏ ÏÉùÏÑ±ÌñàÏñ¥Ïöî ‚ñ∂ Ïä§ÌÇµ", use_container_width=True):
            if not ss.mbm_title:
                st.error("ÌÉÄÏù¥ÌãÄÏùÑ ÏûÖÎ†•Ìï¥Ïïº Îã§Ïùå Îã®Í≥ÑÎ°ú Ïù¥ÎèôÌï† Ïàò ÏûàÏñ¥Ïöî.")
            else:
                ss.mbm_submitted = True
                ss.active_stage = 2
                st.success("MBM Ïò§Î∏åÏ†ùÌä∏ ÏÉùÏÑ± Îã®Í≥ÑÎ•º Í±¥ÎÑàÎúÅÎãàÎã§. ‚ÄòÌõÑÏÜç ÏûëÏóÖ ÏÑ†ÌÉù‚Äô ÌÉ≠ÏúºÎ°ú Ïù¥ÎèôÌï©ÎãàÎã§.")
                st.rerun()
    with cc:
        st.empty()

    # 1-2) ÏÉÅÏÑ∏ ÏÜçÏÑ± Ìèº (ÌÉÄÏù¥ÌãÄ Ï†úÏ∂ú ÌõÑ ÌëúÏãú) ‚Äî Ïä§ÌÇ§Îßà Í∏∞Î∞ò ÏúÑÏ†Ø
    if ss.show_prop_form and not ss.mbm_submitted:
        st.markdown("---")
        st.markdown("#### MBM Ïò§Î∏åÏ†ùÌä∏ ÏÑ∏Î∂Ä Ìï≠Î™©")

        # Ïä§ÌÇ§Îßà Î©îÌÉÄ Î∂àÎü¨Ïò§Í∏∞
        try:
            props_map = get_mbm_properties_map()
        except Exception as e:
            st.error(f"Ïä§ÌÇ§Îßà Î°úÎìú Ïã§Ìå®: {e}")
            props_map = {}

        def render_field(name: str, meta: dict):
            lbl = human_label(name)
            ptype = (meta.get("type") or "").lower()
            options = meta.get("options") or []
            key = f"fld_{name}"

            # Ïó¥Í±∞Ìòï ‚Üí selectbox
            if ptype in ("enumeration", "enumerationoptions", "enum") or options:
                labels = [opt.get("label") or opt.get("display") or opt.get("value") for opt in options]
                values = [opt.get("value") for opt in options]
                if not labels:
                    return st.text_input(lbl, key=key)
                idx_opt = st.selectbox(lbl, options=list(range(len(labels))),
                                       format_func=lambda i: labels[i], key=key)
                return values[idx_opt]

            # ÎÇ†Ïßú/ÏùºÏãú
            if ptype in ("date", "datetime"):
                d = st.date_input(lbl, value=None, format="YYYY-MM-DD", key=key)
                return to_epoch_ms(d) if d else None

            # Î∂àÎ¶¨Ïñ∏
            if ptype in ("bool", "boolean"):
                v = st.checkbox(lbl, value=False, key=key)
                return "true" if v else "false"

            # Ïà´Ïûê
            if ptype in ("number", "integer", "long", "double"):
                return str(int(st.number_input(lbl, min_value=0.0, step=1.0, format="%.0f", key=key)))

            # Í∏¥ ÌÖçÏä§Ìä∏ ÌõÑÎ≥¥ ‚Üí text_area
            if name in LONG_TEXT_FIELDS:
                return st.text_area(lbl, height=100, key=key)

            # Í∏∞Î≥∏: ÌÖçÏä§Ìä∏
            return st.text_input(lbl, key=key)

        with st.form("mbm_props_form", clear_on_submit=False):
            hidden_true = "true"  # auto_generate_campaign

            values = {}
            for n in MBM_FIELDS:
                meta = props_map.get(n, {})
                if n == "title":
                    values[n] = st.text_input(human_label(n), value=ss.mbm_title, key="fld_title_override")
                else:
                    values[n] = render_field(n, meta)

            submitted_obj = st.form_submit_button("MBM Ïò§Î∏åÏ†ùÌä∏ ÏÉùÏÑ±ÌïòÍ∏∞", type="primary")

        if submitted_obj:
            if not values.get("title"):
                st.error("ÌÉÄÏù¥ÌãÄÏùÄ ÌïÑÏàòÏûÖÎãàÎã§.")
                st.stop()

            payload = {k: v for k, v in values.items() if v not in (None, "")}
            payload[MBM_HIDDEN_TRUE] = hidden_true

            try:
                with st.spinner("HubSpotÏóê MBM Ïò§Î∏åÏ†ùÌä∏ ÏÉùÏÑ± Ï§ë‚Ä¶"):
                    created = hs_create_mbm_object(payload)
                    ss.mbm_object = created
                    ss.mbm_title = values["title"]
                    ss.mbm_submitted = True
                    ss.active_stage = 2
                    st.success("ÏÉùÏÑ± ÏôÑÎ£å! ‚ÄòÌõÑÏÜç ÏûëÏóÖ ÏÑ†ÌÉù‚Äô ÌÉ≠ÏúºÎ°ú Ïù¥ÎèôÌï©ÎãàÎã§.")
                    st.rerun()
            except requests.HTTPError as http_err:
                st.error(f"HubSpot API Ïò§Î•ò: {http_err.response.status_code} - {http_err.response.text}")
            except Exception as e:
                st.error(f"Ïã§Ìå®: {e}")

# =============== ÌÉ≠‚ë°: ÌõÑÏÜç ÏûëÏóÖ ÏÑ†ÌÉù ===============
if ss.mbm_submitted:
    with tabs[idx[TAB2]]:
        st.markdown("### ‚ë° ÌõÑÏÜç ÏûëÏóÖ ÏÑ†ÌÉù")
        if ss.mbm_object:
            st.info(f"MBM Ïò§Î∏åÏ†ùÌä∏ ÏÉùÏÑ±Îê®: [Ïó¥Í∏∞]({ss.mbm_object.get('url')})")

        with st.form("post_submit_actions"):
            c1, c2 = st.columns([2, 1], gap="large")
            with c1:
                st.markdown("**MBM Ïò§Î∏åÏ†ùÌä∏ ÌÉÄÏù¥ÌãÄ (ÏùΩÍ∏∞ Ï†ÑÏö©)**")
                st.text_input("MBM Title", value=ss.mbm_title, disabled=True, label_visibility="collapsed")
            with c2:
                st.markdown("**ÏÉùÏÑ±Ìï† ÏûêÏÇ∞**")
                make_wp = st.checkbox("ÏõπÌéòÏù¥ÏßÄ Î≥µÏ†ú", value=True)  # Website Ï†ÑÏö©
                make_em = st.checkbox("Ïù¥Î©îÏùº Î≥µÏ†ú", value=True)
                email_count = st.number_input("Ïù¥Î©îÏùº Î≥µÏ†ú Í∞úÏàò", min_value=1, max_value=10, value=1, step=1)

            submitted_actions = st.form_submit_button("ÏÉùÏÑ±ÌïòÍ∏∞", type="primary")

        if submitted_actions:
            links = {"Website Page": [], "Email": [], "Form": []}
            try:
                # Website Page
                if make_wp:
                    page_name = f"{ss.mbm_title}_landing page"
                    with st.spinner(f"ÏõπÌéòÏù¥ÏßÄ Î≥µÏ†ú Ï§ë‚Ä¶ ({page_name})"):
                        page_data = clone_site_page_with_fallback(
                            LANDING_PAGE_TEMPLATE_ID, page_name, WEBSITE_PAGE_TEMPLATE_TITLE
                        )
                        page_id = str(page_data.get("id") or page_data.get("objectId") or "")
                        hs_update_site_page_name(page_id, page_name)
                        hs_push_live_site(page_id)
                        try:
                            refreshed = hs_get_site_page(page_id)
                        except Exception:
                            refreshed = page_data
                        live_url = extract_best_live_url(refreshed) or f"https://app.hubspot.com/cms/{PORTAL_ID}/website/pages/{page_id}/view"
                        links["Website Page"].append(("Î≥¥Í∏∞", live_url))

                # Emails
                if make_em:
                    for i in range(1, int(email_count) + 1):
                        email_name = f"{ss.mbm_title}_email_{ordinal(i)}"
                        with st.spinner(f"ÎßàÏºÄÌåÖ Ïù¥Î©îÏùº Î≥µÏ†ú Ï§ë‚Ä¶ ({email_name})"):
                            em = hs_clone_marketing_email(EMAIL_TEMPLATE_ID, email_name)
                            em_id = str(em.get("id") or em.get("contentId") or "")
                            hs_update_email_name(em_id, email_name)
                            edit_url = f"https://app.hubspot.com/email/{PORTAL_ID}/edit/{em_id}/settings"
                            links["Email"].append((f"Email {ordinal(i)}", edit_url))

                # Register Form
                form_name = f"{ss.mbm_title}_register form"
                with st.spinner(f"Register Form Î≥µÏ†ú Ï§ë‚Ä¶ ({form_name})"):
                    new_form = clone_form_with_hidden_value(
                        REGISTER_FORM_TEMPLATE_GUID, form_name, ss.mbm_title, MBM_HIDDEN_FIELD_NAME
                    )
                    new_guid = new_form.get("guid") or new_form.get("id")
                    edit_url = f"https://app.hubspot.com/forms/{PORTAL_ID}/{new_guid}/edit"
                    links["Form"].append(("Ìé∏Ïßë", edit_url))

                ss.results = {"title": ss.mbm_title, "links": links}
                ss.active_stage = 3
                st.success("ÏÉùÏÑ±Ïù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§. ‚ÄòÏµúÏ¢Ö ÎßÅÌÅ¨ Í≥µÏú†‚Äô ÌÉ≠ÏúºÎ°ú Ïù¥ÎèôÌï©ÎãàÎã§.")
                st.rerun()

            except requests.HTTPError as http_err:
                st.error(f"HubSpot API Ïò§Î•ò: {http_err.response.status_code} - {http_err.response.text}")
            except Exception as e:
                st.error(f"Ïã§Ìå®: {e}")

# =============== ÌÉ≠‚ë¢: ÏµúÏ¢Ö ÎßÅÌÅ¨ Í≥µÏú† ===============
if ss.results:
    with tabs[idx[TAB3]]:
        st.markdown("### ‚ë¢ ÏµúÏ¢Ö ÎßÅÌÅ¨ Í≥µÏú†")
        st.success(f"MBM ÏÉùÏÑ± Í≤∞Í≥º ‚Äì **{ss.results['title']}**")

        def link_box(title: str, items: list[tuple[str, str]], prefix_key: str):
            st.markdown(f"#### {title}")
            for i, (label, url) in enumerate(items, start=1):
                box = st.container(border=True)
                with box:
                    c1, c2 = st.columns([8, 1])
                    with c1:
                        st.markdown(f"**{label}**  \n{url}")
                    with c2:
                        copy_button(url, key=f"{prefix_key}_{i}_{uuid.uuid4()}")

        if ss.results["links"].get("Website Page"):
            link_box("Website Page", ss.results["links"]["Website Page"], "lp")
        if ss.results["links"].get("Email"):
            link_box("Marketing Emails", ss.results["links"]["Email"], "em")
        if ss.results["links"].get("Form"):
            link_box("Register Form", ss.results["links"]["Form"], "fm")

        st.divider()

        # Ï†ÑÏ≤¥ Í≤∞Í≥º ÌÖçÏä§Ìä∏ + Î≥µÏÇ¨ Î≤ÑÌäº(ÏïÑÎûò)
        lines = [f"[MBM] ÏÉùÏÑ± Í≤∞Í≥º - {ss.results['title']}", ""]
        if ss.results["links"].get("Website Page"):
            lines.append("‚ñº Website Page")
            for label, url in ss.results["links"]["Website Page"]:
                lines.append(f"- {label}: {url}")
            lines.append("")
        if ss.results["links"].get("Email"):
            lines.append("‚ñº Marketing Emails")
            for label, url in ss.results["links"]["Email"]:
                lines.append(f"- {label}: {url}")
            lines.append("")
        if ss.results["links"].get("Form"):
            lines.append("‚ñº Register Form")
            for label, url in ss.results["links"]["Form"]:
                lines.append(f"- {label}: {url}")
            lines.append("")

        all_text = "\n".join(lines)
        st.text_area("Ï†ÑÏ≤¥ Í≤∞Í≥º (ÎØ∏Î¶¨Î≥¥Í∏∞)", value=all_text, height=180, label_visibility="collapsed")
        if st.button("Ï†ÑÏ≤¥ Í≤∞Í≥ºÎ¨º Î≥µÏÇ¨", type="primary"):
            st.components.v1.html(
                f"<script>navigator.clipboard.writeText({json.dumps(all_text)});</script>",
                height=0, width=0
            )
            st.toast("Î≥µÏÇ¨Í∞Ä ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§. Î©îÎ™®Ïû•Ïóê Î∂ôÏó¨ÎÑ£Í∏∞ ÌïòÏÑ∏Ïöî")
